
Pos : @value type = {
    public x : int;
    public y : int;

    operator=: (out this) = {
        this.x = 0;
        this.y = 0;
    }

    operator=: (out this, _x : int, _y : int) = {
        this.x = _x;
        this.y = _y;
    }

    operator+=: (inout this, rhs : Pos) = {
        this.x += rhs.x;
        this.y += rhs.y;
    }

    operator*=: (inout this, scalar : int) = {
        this.x *= scalar;
        this.y *= scalar;
    }
}

Step : @value type = {
    public position: Pos = ();
    public depth : int = 0;
}

readFile: (path: std::string) -> std::vector<std::string> = {
    data : std::vector<std::string> = ();
    input : std::ifstream = (path);
    line : std::string = "";

    while (std::getline(input, line)) {
        data.push_back(line);
    }

    input.close();
    return data;
}

findStart : (data : std::vector<std::string>) -> Pos = {
    result : Pos = ();

    j := 0;
    while j < data.ssize() next j++ {
        i := 0;
        while i < data[j].ssize() next i++ {
            if data[j][i] == 'S' {
                result = Pos(i, j);
            }
        }
    }

    return result;
}

isValidMove: (data : std::vector<std::string>, position : Pos) -> bool = {
    if position.x < 0 || position.x >= data[0].ssize() || position.y < 0 || position.y >= data.ssize() {
        return false;
    }
    return data[position.y][position.x] == '.';
}

main: () -> int = {
    MAX_DEPTH := 6;
    MOVE_OFFSETS : std::vector<Pos> = (Pos(-1, 0), Pos(0, 1), Pos(1, 0), Pos(0, -1));

    result := 0;
    data := readFile("input.txt");

    start := findStart(data);
    data[start.y][start.x] = '.';

    startStep : Step = ();
    startStep.position = start;
    q : std::queue<Step> = ();
    q.push(startStep);

    while q.ssize() > 0 {
        step := q.front();
        if step.depth == MAX_DEPTH {
            break;
        }
        q.pop();

        for MOVE_OFFSETS do (offset) {
            pos := step.position;
            pos += offset;
            if isValidMove(data, pos) {
                nextStep : Step = ();
                nextStep.position = pos;
                nextStep.depth = step.depth + 1;
                q.push(nextStep);
            }            
        }

        std::cout << step.depth << std::endl;
    }

    

    result = q.ssize();

    std::cout << "Result: " << result << std::endl;
}
